"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/neverthrow";
exports.ids = ["vendor-chunks/neverthrow"];
exports.modules = {

/***/ "(rsc)/./node_modules/neverthrow/dist/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/neverthrow/dist/index.es.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Err: () => (/* binding */ Err),\n/* harmony export */   Ok: () => (/* binding */ Ok),\n/* harmony export */   Result: () => (/* binding */ Result),\n/* harmony export */   ResultAsync: () => (/* binding */ ResultAsync),\n/* harmony export */   err: () => (/* binding */ err),\n/* harmony export */   errAsync: () => (/* binding */ errAsync),\n/* harmony export */   fromPromise: () => (/* binding */ fromPromise),\n/* harmony export */   fromSafePromise: () => (/* binding */ fromSafePromise),\n/* harmony export */   fromThrowable: () => (/* binding */ fromThrowable),\n/* harmony export */   ok: () => (/* binding */ ok),\n/* harmony export */   okAsync: () => (/* binding */ okAsync),\n/* harmony export */   safeTry: () => (/* binding */ safeTry)\n/* harmony export */ });\nconst defaultErrorConfig = {\n    withStackTrace: false\n};\n// Custom error object\n// Context / discussion: https://github.com/supermacro/neverthrow/pull/215\nconst createNeverThrowError = (message, result, config = defaultErrorConfig)=>{\n    const data = result.isOk() ? {\n        type: \"Ok\",\n        value: result.value\n    } : {\n        type: \"Err\",\n        value: result.error\n    };\n    const maybeStack = config.withStackTrace ? new Error().stack : undefined;\n    return {\n        data,\n        message,\n        stack: maybeStack\n    };\n};\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function verb(n) {\n        if (g[n]) i[n] = function(v) {\n            return new Promise(function(a, b) {\n                q.push([\n                    n,\n                    v,\n                    a,\n                    b\n                ]) > 1 || resume(n, v);\n            });\n        };\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n}\nfunction __asyncDelegator(o) {\n    var i, p;\n    return i = {}, verb(\"next\"), verb(\"throw\", function(e) {\n        throw e;\n    }), verb(\"return\"), i[Symbol.iterator] = function() {\n        return this;\n    }, i;\n    function verb(n, f) {\n        i[n] = o[n] ? function(v) {\n            return (p = !p) ? {\n                value: __await(o[n](v)),\n                done: n === \"return\"\n            } : f ? f(v) : v;\n        } : f;\n    }\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\nclass ResultAsync {\n    constructor(res){\n        this._promise = res;\n    }\n    static fromSafePromise(promise) {\n        const newPromise = promise.then((value)=>new Ok(value));\n        return new ResultAsync(newPromise);\n    }\n    static fromPromise(promise, errorFn) {\n        const newPromise = promise.then((value)=>new Ok(value)).catch((e)=>new Err(errorFn(e)));\n        return new ResultAsync(newPromise);\n    }\n    static combine(asyncResultList) {\n        return combineResultAsyncList(asyncResultList);\n    }\n    static combineWithAllErrors(asyncResultList) {\n        return combineResultAsyncListWithAllErrors(asyncResultList);\n    }\n    map(f) {\n        return new ResultAsync(this._promise.then((res)=>__awaiter(this, void 0, void 0, function*() {\n                if (res.isErr()) {\n                    return new Err(res.error);\n                }\n                return new Ok((yield f(res.value)));\n            })));\n    }\n    mapErr(f) {\n        return new ResultAsync(this._promise.then((res)=>__awaiter(this, void 0, void 0, function*() {\n                if (res.isOk()) {\n                    return new Ok(res.value);\n                }\n                return new Err((yield f(res.error)));\n            })));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    andThen(f) {\n        return new ResultAsync(this._promise.then((res)=>{\n            if (res.isErr()) {\n                return new Err(res.error);\n            }\n            const newValue = f(res.value);\n            return newValue instanceof ResultAsync ? newValue._promise : newValue;\n        }));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    orElse(f) {\n        return new ResultAsync(this._promise.then((res)=>__awaiter(this, void 0, void 0, function*() {\n                if (res.isErr()) {\n                    return f(res.error);\n                }\n                return new Ok(res.value);\n            })));\n    }\n    match(ok, _err) {\n        return this._promise.then((res)=>res.match(ok, _err));\n    }\n    unwrapOr(t) {\n        return this._promise.then((res)=>res.unwrapOr(t));\n    }\n    /**\r\n     * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.\r\n     */ safeUnwrap() {\n        return __asyncGenerator(this, arguments, function* safeUnwrap_1() {\n            return yield __await((yield __await((yield* __asyncDelegator(__asyncValues((yield __await(this._promise.then((res)=>res.safeUnwrap())))))))));\n        });\n    }\n    // Makes ResultAsync implement PromiseLike<Result>\n    then(successCallback, failureCallback) {\n        return this._promise.then(successCallback, failureCallback);\n    }\n}\nconst okAsync = (value)=>new ResultAsync(Promise.resolve(new Ok(value)));\nconst errAsync = (err)=>new ResultAsync(Promise.resolve(new Err(err)));\nconst fromPromise = ResultAsync.fromPromise;\nconst fromSafePromise = ResultAsync.fromSafePromise;\nconst appendValueToEndOfList = (value)=>(list)=>[\n            ...list,\n            value\n        ];\n/**\r\n * Short circuits on the FIRST Err value that we find\r\n */ const combineResultList = (resultList)=>resultList.reduce((acc, result)=>acc.isOk() ? result.isErr() ? err(result.error) : acc.map(appendValueToEndOfList(result.value)) : acc, ok([]));\n/* This is the typesafe version of Promise.all\r\n *\r\n * Takes a list of ResultAsync<T, E> and success if all inner results are Ok values\r\n * or fails if one (or more) of the inner results are Err values\r\n */ const combineResultAsyncList = (asyncResultList)=>ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);\n/**\r\n * Give a list of all the errors we find\r\n */ const combineResultListWithAllErrors = (resultList)=>resultList.reduce((acc, result)=>result.isErr() ? acc.isErr() ? err([\n            ...acc.error,\n            result.error\n        ]) : err([\n            result.error\n        ]) : acc.isErr() ? acc : ok([\n            ...acc.value,\n            result.value\n        ]), ok([]));\nconst combineResultAsyncListWithAllErrors = (asyncResultList)=>ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Result;\n(function(Result) {\n    /**\r\n     * Wraps a function with a try catch, creating a new function with the same\r\n     * arguments but returning `Ok` if successful, `Err` if the function throws\r\n     *\r\n     * @param fn function to wrap with ok on success or err on failure\r\n     * @param errorFn when an error is thrown, this will wrap the error result if provided\r\n     */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function fromThrowable(fn, errorFn) {\n        return (...args)=>{\n            try {\n                const result = fn(...args);\n                return ok(result);\n            } catch (e) {\n                return err(errorFn ? errorFn(e) : e);\n            }\n        };\n    }\n    Result.fromThrowable = fromThrowable;\n    function combine(resultList) {\n        return combineResultList(resultList);\n    }\n    Result.combine = combine;\n    function combineWithAllErrors(resultList) {\n        return combineResultListWithAllErrors(resultList);\n    }\n    Result.combineWithAllErrors = combineWithAllErrors;\n})(Result || (Result = {}));\nconst ok = (value)=>new Ok(value);\nconst err = (err)=>new Err(err);\nfunction safeTry(body) {\n    const n = body().next();\n    if (n instanceof Promise) {\n        return n.then((r)=>r.value);\n    }\n    return n.value;\n}\nclass Ok {\n    constructor(value){\n        this.value = value;\n    }\n    isOk() {\n        return true;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n    map(f) {\n        return ok(f(this.value));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    mapErr(_f) {\n        return ok(this.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    andThen(f) {\n        return f(this.value);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    orElse(_f) {\n        return ok(this.value);\n    }\n    asyncAndThen(f) {\n        return f(this.value);\n    }\n    asyncMap(f) {\n        return ResultAsync.fromSafePromise(f(this.value));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    unwrapOr(_v) {\n        return this.value;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    match(ok, _err) {\n        return ok(this.value);\n    }\n    safeUnwrap() {\n        const value = this.value;\n        /* eslint-disable-next-line require-yield */ return function*() {\n            return value;\n        }();\n    }\n    _unsafeUnwrap(_) {\n        return this.value;\n    }\n    _unsafeUnwrapErr(config) {\n        throw createNeverThrowError(\"Called `_unsafeUnwrapErr` on an Ok\", this, config);\n    }\n}\nclass Err {\n    constructor(error){\n        this.error = error;\n    }\n    isOk() {\n        return false;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    map(_f) {\n        return err(this.error);\n    }\n    mapErr(f) {\n        return err(f(this.error));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    andThen(_f) {\n        return err(this.error);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    orElse(f) {\n        return f(this.error);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asyncAndThen(_f) {\n        return errAsync(this.error);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asyncMap(_f) {\n        return errAsync(this.error);\n    }\n    unwrapOr(v) {\n        return v;\n    }\n    match(_ok, err) {\n        return err(this.error);\n    }\n    safeUnwrap() {\n        const error = this.error;\n        return function*() {\n            yield err(error);\n            throw new Error(\"Do not use this generator out of `safeTry`\");\n        }();\n    }\n    _unsafeUnwrap(config) {\n        throw createNeverThrowError(\"Called `_unsafeUnwrap` on an Err\", this, config);\n    }\n    _unsafeUnwrapErr(_) {\n        return this.error;\n    }\n}\nconst fromThrowable = Result.fromThrowable;\n//#endregion\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV2ZXJ0aHJvdy9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE1BQU1BLHFCQUFxQjtJQUN2QkMsZ0JBQWdCO0FBQ3BCO0FBQ0Esc0JBQXNCO0FBQ3RCLDBFQUEwRTtBQUMxRSxNQUFNQyx3QkFBd0IsQ0FBQ0MsU0FBU0MsUUFBUUMsU0FBU0wsa0JBQWtCO0lBQ3ZFLE1BQU1NLE9BQU9GLE9BQU9HLElBQUksS0FDbEI7UUFBRUMsTUFBTTtRQUFNQyxPQUFPTCxPQUFPSyxLQUFLO0lBQUMsSUFDbEM7UUFBRUQsTUFBTTtRQUFPQyxPQUFPTCxPQUFPTSxLQUFLO0lBQUM7SUFDekMsTUFBTUMsYUFBYU4sT0FBT0osY0FBYyxHQUFHLElBQUlXLFFBQVFDLEtBQUssR0FBR0M7SUFDL0QsT0FBTztRQUNIUjtRQUNBSDtRQUNBVSxPQUFPRjtJQUNYO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsU0FBU0ksVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNWCxLQUFLO1FBQUksT0FBT0EsaUJBQWlCUyxJQUFJVCxRQUFRLElBQUlTLEVBQUUsU0FBVUcsT0FBTztZQUFJQSxRQUFRWjtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLUyxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSSxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVWYsS0FBSztZQUFJLElBQUk7Z0JBQUVnQixLQUFLTixVQUFVTyxJQUFJLENBQUNqQjtZQUFTLEVBQUUsT0FBT2tCLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTbkIsS0FBSztZQUFJLElBQUk7Z0JBQUVnQixLQUFLTixTQUFTLENBQUMsUUFBUSxDQUFDVjtZQUFTLEVBQUUsT0FBT2tCLEdBQUc7Z0JBQUVKLE9BQU9J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ekI7SUFDQSxpSEFBaUg7SUFDakgyRSxPQUFPNUIsQ0FBQyxFQUFFO1FBQ04sT0FBT0EsRUFBRSxJQUFJLENBQUMvQyxLQUFLO0lBQ3ZCO0lBQ0EsNkRBQTZEO0lBQzdEd0csYUFBYUQsRUFBRSxFQUFFO1FBQ2IsT0FBT2hCLFNBQVMsSUFBSSxDQUFDdkYsS0FBSztJQUM5QjtJQUNBLDZEQUE2RDtJQUM3RHlHLFNBQVNGLEVBQUUsRUFBRTtRQUNULE9BQU9oQixTQUFTLElBQUksQ0FBQ3ZGLEtBQUs7SUFDOUI7SUFDQStFLFNBQVM5QyxDQUFDLEVBQUU7UUFDUixPQUFPQTtJQUNYO0lBQ0EyQyxNQUFNa0MsR0FBRyxFQUFFdEIsR0FBRyxFQUFFO1FBQ1osT0FBT0EsSUFBSSxJQUFJLENBQUN4RixLQUFLO0lBQ3pCO0lBQ0FpRixhQUFhO1FBQ1QsTUFBTWpGLFFBQVEsSUFBSSxDQUFDQSxLQUFLO1FBQ3hCLE9BQU87WUFDSCxNQUFNd0YsSUFBSXhGO1lBQ1YsTUFBTSxJQUFJRSxNQUFNO1FBQ3BCO0lBQ0o7SUFDQXlHLGNBQWNoSCxNQUFNLEVBQUU7UUFDbEIsTUFBTUgsc0JBQXNCLG9DQUFvQyxJQUFJLEVBQUVHO0lBQzFFO0lBQ0FrSCxpQkFBaUJELENBQUMsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQzVHLEtBQUs7SUFDckI7QUFDSjtBQUNBLE1BQU1rRyxnQkFBZ0JELE9BQU9DLGFBQWE7QUFDMUMsWUFBWTtBQUU4RyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyYW1lLXR1dG9yaWFsLy4vbm9kZV9tb2R1bGVzL25ldmVydGhyb3cvZGlzdC9pbmRleC5lcy5qcz8wOGU5Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGRlZmF1bHRFcnJvckNvbmZpZyA9IHtcclxuICAgIHdpdGhTdGFja1RyYWNlOiBmYWxzZSxcclxufTtcclxuLy8gQ3VzdG9tIGVycm9yIG9iamVjdFxyXG4vLyBDb250ZXh0IC8gZGlzY3Vzc2lvbjogaHR0cHM6Ly9naXRodWIuY29tL3N1cGVybWFjcm8vbmV2ZXJ0aHJvdy9wdWxsLzIxNVxyXG5jb25zdCBjcmVhdGVOZXZlclRocm93RXJyb3IgPSAobWVzc2FnZSwgcmVzdWx0LCBjb25maWcgPSBkZWZhdWx0RXJyb3JDb25maWcpID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSByZXN1bHQuaXNPaygpXHJcbiAgICAgICAgPyB7IHR5cGU6ICdPaycsIHZhbHVlOiByZXN1bHQudmFsdWUgfVxyXG4gICAgICAgIDogeyB0eXBlOiAnRXJyJywgdmFsdWU6IHJlc3VsdC5lcnJvciB9O1xyXG4gICAgY29uc3QgbWF5YmVTdGFjayA9IGNvbmZpZy53aXRoU3RhY2tUcmFjZSA/IG5ldyBFcnJvcigpLnN0YWNrIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkYXRhLFxyXG4gICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgc3RhY2s6IG1heWJlU3RhY2ssXHJcbiAgICB9O1xyXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxuXG5jbGFzcyBSZXN1bHRBc3luYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXMpIHtcclxuICAgICAgICB0aGlzLl9wcm9taXNlID0gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21TYWZlUHJvbWlzZShwcm9taXNlKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UHJvbWlzZSA9IHByb21pc2UudGhlbigodmFsdWUpID0+IG5ldyBPayh2YWx1ZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0QXN5bmMobmV3UHJvbWlzZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVByb21pc2UocHJvbWlzZSwgZXJyb3JGbikge1xyXG4gICAgICAgIGNvbnN0IG5ld1Byb21pc2UgPSBwcm9taXNlXHJcbiAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4gbmV3IE9rKHZhbHVlKSlcclxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiBuZXcgRXJyKGVycm9yRm4oZSkpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdEFzeW5jKG5ld1Byb21pc2UpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbWJpbmUoYXN5bmNSZXN1bHRMaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVSZXN1bHRBc3luY0xpc3QoYXN5bmNSZXN1bHRMaXN0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjb21iaW5lV2l0aEFsbEVycm9ycyhhc3luY1Jlc3VsdExpc3QpIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZVJlc3VsdEFzeW5jTGlzdFdpdGhBbGxFcnJvcnMoYXN5bmNSZXN1bHRMaXN0KTtcclxuICAgIH1cclxuICAgIG1hcChmKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRBc3luYyh0aGlzLl9wcm9taXNlLnRoZW4oKHJlcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAocmVzLmlzRXJyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyKHJlcy5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPayh5aWVsZCBmKHJlcy52YWx1ZSkpO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgICBtYXBFcnIoZikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVzdWx0QXN5bmModGhpcy5fcHJvbWlzZS50aGVuKChyZXMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcy5pc09rKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT2socmVzLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycih5aWVsZCBmKHJlcy5lcnJvcikpO1xyXG4gICAgICAgIH0pKSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xyXG4gICAgYW5kVGhlbihmKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRBc3luYyh0aGlzLl9wcm9taXNlLnRoZW4oKHJlcykgPT4ge1xyXG4gICAgICAgICAgICBpZiAocmVzLmlzRXJyKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyKHJlcy5lcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBmKHJlcy52YWx1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdWYWx1ZSBpbnN0YW5jZW9mIFJlc3VsdEFzeW5jID8gbmV3VmFsdWUuX3Byb21pc2UgOiBuZXdWYWx1ZTtcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xyXG4gICAgb3JFbHNlKGYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdEFzeW5jKHRoaXMuX3Byb21pc2UudGhlbigocmVzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMuaXNFcnIoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGYocmVzLmVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE9rKHJlcy52YWx1ZSk7XHJcbiAgICAgICAgfSkpKTtcclxuICAgIH1cclxuICAgIG1hdGNoKG9rLCBfZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2UudGhlbigocmVzKSA9PiByZXMubWF0Y2gob2ssIF9lcnIpKTtcclxuICAgIH1cclxuICAgIHVud3JhcE9yKHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZS50aGVuKChyZXMpID0+IHJlcy51bndyYXBPcih0KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtdWxhdGVzIFJ1c3QncyBgP2Agb3BlcmF0b3IgaW4gYHNhZmVUcnlgJ3MgYm9keS4gU2VlIGFsc28gYHNhZmVUcnlgLlxyXG4gICAgICovXHJcbiAgICBzYWZlVW53cmFwKCkge1xyXG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIHNhZmVVbndyYXBfMSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9fYXdhaXQoeWllbGQgX19hd2FpdCh5aWVsZCogX19hc3luY0RlbGVnYXRvcihfX2FzeW5jVmFsdWVzKHlpZWxkIF9fYXdhaXQodGhpcy5fcHJvbWlzZS50aGVuKChyZXMpID0+IHJlcy5zYWZlVW53cmFwKCkpKSkpKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBNYWtlcyBSZXN1bHRBc3luYyBpbXBsZW1lbnQgUHJvbWlzZUxpa2U8UmVzdWx0PlxyXG4gICAgdGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IG9rQXN5bmMgPSAodmFsdWUpID0+IG5ldyBSZXN1bHRBc3luYyhQcm9taXNlLnJlc29sdmUobmV3IE9rKHZhbHVlKSkpO1xyXG5jb25zdCBlcnJBc3luYyA9IChlcnIpID0+IG5ldyBSZXN1bHRBc3luYyhQcm9taXNlLnJlc29sdmUobmV3IEVycihlcnIpKSk7XHJcbmNvbnN0IGZyb21Qcm9taXNlID0gUmVzdWx0QXN5bmMuZnJvbVByb21pc2U7XHJcbmNvbnN0IGZyb21TYWZlUHJvbWlzZSA9IFJlc3VsdEFzeW5jLmZyb21TYWZlUHJvbWlzZTtcblxuY29uc3QgYXBwZW5kVmFsdWVUb0VuZE9mTGlzdCA9ICh2YWx1ZSkgPT4gKGxpc3QpID0+IFsuLi5saXN0LCB2YWx1ZV07XHJcbi8qKlxyXG4gKiBTaG9ydCBjaXJjdWl0cyBvbiB0aGUgRklSU1QgRXJyIHZhbHVlIHRoYXQgd2UgZmluZFxyXG4gKi9cclxuY29uc3QgY29tYmluZVJlc3VsdExpc3QgPSAocmVzdWx0TGlzdCkgPT4gcmVzdWx0TGlzdC5yZWR1Y2UoKGFjYywgcmVzdWx0KSA9PiBhY2MuaXNPaygpXHJcbiAgICA/IHJlc3VsdC5pc0VycigpXHJcbiAgICAgICAgPyBlcnIocmVzdWx0LmVycm9yKVxyXG4gICAgICAgIDogYWNjLm1hcChhcHBlbmRWYWx1ZVRvRW5kT2ZMaXN0KHJlc3VsdC52YWx1ZSkpXHJcbiAgICA6IGFjYywgb2soW10pKTtcclxuLyogVGhpcyBpcyB0aGUgdHlwZXNhZmUgdmVyc2lvbiBvZiBQcm9taXNlLmFsbFxyXG4gKlxyXG4gKiBUYWtlcyBhIGxpc3Qgb2YgUmVzdWx0QXN5bmM8VCwgRT4gYW5kIHN1Y2Nlc3MgaWYgYWxsIGlubmVyIHJlc3VsdHMgYXJlIE9rIHZhbHVlc1xyXG4gKiBvciBmYWlscyBpZiBvbmUgKG9yIG1vcmUpIG9mIHRoZSBpbm5lciByZXN1bHRzIGFyZSBFcnIgdmFsdWVzXHJcbiAqL1xyXG5jb25zdCBjb21iaW5lUmVzdWx0QXN5bmNMaXN0ID0gKGFzeW5jUmVzdWx0TGlzdCkgPT4gUmVzdWx0QXN5bmMuZnJvbVNhZmVQcm9taXNlKFByb21pc2UuYWxsKGFzeW5jUmVzdWx0TGlzdCkpLmFuZFRoZW4oY29tYmluZVJlc3VsdExpc3QpO1xyXG4vKipcclxuICogR2l2ZSBhIGxpc3Qgb2YgYWxsIHRoZSBlcnJvcnMgd2UgZmluZFxyXG4gKi9cclxuY29uc3QgY29tYmluZVJlc3VsdExpc3RXaXRoQWxsRXJyb3JzID0gKHJlc3VsdExpc3QpID0+IHJlc3VsdExpc3QucmVkdWNlKChhY2MsIHJlc3VsdCkgPT4gcmVzdWx0LmlzRXJyKClcclxuICAgID8gYWNjLmlzRXJyKClcclxuICAgICAgICA/IGVycihbLi4uYWNjLmVycm9yLCByZXN1bHQuZXJyb3JdKVxyXG4gICAgICAgIDogZXJyKFtyZXN1bHQuZXJyb3JdKVxyXG4gICAgOiBhY2MuaXNFcnIoKVxyXG4gICAgICAgID8gYWNjXHJcbiAgICAgICAgOiBvayhbLi4uYWNjLnZhbHVlLCByZXN1bHQudmFsdWVdKSwgb2soW10pKTtcclxuY29uc3QgY29tYmluZVJlc3VsdEFzeW5jTGlzdFdpdGhBbGxFcnJvcnMgPSAoYXN5bmNSZXN1bHRMaXN0KSA9PiBSZXN1bHRBc3luYy5mcm9tU2FmZVByb21pc2UoUHJvbWlzZS5hbGwoYXN5bmNSZXN1bHRMaXN0KSkuYW5kVGhlbihjb21iaW5lUmVzdWx0TGlzdFdpdGhBbGxFcnJvcnMpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5hbWVzcGFjZVxyXG52YXIgUmVzdWx0O1xyXG4oZnVuY3Rpb24gKFJlc3VsdCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSB0cnkgY2F0Y2gsIGNyZWF0aW5nIGEgbmV3IGZ1bmN0aW9uIHdpdGggdGhlIHNhbWVcclxuICAgICAqIGFyZ3VtZW50cyBidXQgcmV0dXJuaW5nIGBPa2AgaWYgc3VjY2Vzc2Z1bCwgYEVycmAgaWYgdGhlIGZ1bmN0aW9uIHRocm93c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmbiBmdW5jdGlvbiB0byB3cmFwIHdpdGggb2sgb24gc3VjY2VzcyBvciBlcnIgb24gZmFpbHVyZVxyXG4gICAgICogQHBhcmFtIGVycm9yRm4gd2hlbiBhbiBlcnJvciBpcyB0aHJvd24sIHRoaXMgd2lsbCB3cmFwIHRoZSBlcnJvciByZXN1bHQgaWYgcHJvdmlkZWRcclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGZ1bmN0aW9uIGZyb21UaHJvd2FibGUoZm4sIGVycm9yRm4pIHtcclxuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9rKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnIoZXJyb3JGbiA/IGVycm9yRm4oZSkgOiBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBSZXN1bHQuZnJvbVRocm93YWJsZSA9IGZyb21UaHJvd2FibGU7XHJcbiAgICBmdW5jdGlvbiBjb21iaW5lKHJlc3VsdExpc3QpIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZVJlc3VsdExpc3QocmVzdWx0TGlzdCk7XHJcbiAgICB9XHJcbiAgICBSZXN1bHQuY29tYmluZSA9IGNvbWJpbmU7XHJcbiAgICBmdW5jdGlvbiBjb21iaW5lV2l0aEFsbEVycm9ycyhyZXN1bHRMaXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVSZXN1bHRMaXN0V2l0aEFsbEVycm9ycyhyZXN1bHRMaXN0KTtcclxuICAgIH1cclxuICAgIFJlc3VsdC5jb21iaW5lV2l0aEFsbEVycm9ycyA9IGNvbWJpbmVXaXRoQWxsRXJyb3JzO1xyXG59KShSZXN1bHQgfHwgKFJlc3VsdCA9IHt9KSk7XHJcbmNvbnN0IG9rID0gKHZhbHVlKSA9PiBuZXcgT2sodmFsdWUpO1xyXG5jb25zdCBlcnIgPSAoZXJyKSA9PiBuZXcgRXJyKGVycik7XHJcbmZ1bmN0aW9uIHNhZmVUcnkoYm9keSkge1xyXG4gICAgY29uc3QgbiA9IGJvZHkoKS5uZXh0KCk7XHJcbiAgICBpZiAobiBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgICByZXR1cm4gbi50aGVuKChyKSA9PiByLnZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuLnZhbHVlO1xyXG59XHJcbmNsYXNzIE9rIHtcclxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgaXNPaygpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlzRXJyKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc09rKCk7XHJcbiAgICB9XHJcbiAgICBtYXAoZikge1xyXG4gICAgICAgIHJldHVybiBvayhmKHRoaXMudmFsdWUpKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgIG1hcEVycihfZikge1xyXG4gICAgICAgIHJldHVybiBvayh0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXHJcbiAgICBhbmRUaGVuKGYpIHtcclxuICAgICAgICByZXR1cm4gZih0aGlzLnZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXHJcbiAgICBvckVsc2UoX2YpIHtcclxuICAgICAgICByZXR1cm4gb2sodGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBhc3luY0FuZFRoZW4oZikge1xyXG4gICAgICAgIHJldHVybiBmKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgYXN5bmNNYXAoZikge1xyXG4gICAgICAgIHJldHVybiBSZXN1bHRBc3luYy5mcm9tU2FmZVByb21pc2UoZih0aGlzLnZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICB1bndyYXBPcihfdikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgbWF0Y2gob2ssIF9lcnIpIHtcclxuICAgICAgICByZXR1cm4gb2sodGhpcy52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBzYWZlVW53cmFwKCkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS15aWVsZCAqL1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICBfdW5zYWZlVW53cmFwKF8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH1cclxuICAgIF91bnNhZmVVbndyYXBFcnIoY29uZmlnKSB7XHJcbiAgICAgICAgdGhyb3cgY3JlYXRlTmV2ZXJUaHJvd0Vycm9yKCdDYWxsZWQgYF91bnNhZmVVbndyYXBFcnJgIG9uIGFuIE9rJywgdGhpcywgY29uZmlnKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFcnIge1xyXG4gICAgY29uc3RydWN0b3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XHJcbiAgICB9XHJcbiAgICBpc09rKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlzRXJyKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc09rKCk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBtYXAoX2YpIHtcclxuICAgICAgICByZXR1cm4gZXJyKHRoaXMuZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgbWFwRXJyKGYpIHtcclxuICAgICAgICByZXR1cm4gZXJyKGYodGhpcy5lcnJvcikpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIGFuZFRoZW4oX2YpIHtcclxuICAgICAgICByZXR1cm4gZXJyKHRoaXMuZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcclxuICAgIG9yRWxzZShmKSB7XHJcbiAgICAgICAgcmV0dXJuIGYodGhpcy5lcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBhc3luY0FuZFRoZW4oX2YpIHtcclxuICAgICAgICByZXR1cm4gZXJyQXN5bmModGhpcy5lcnJvcik7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBhc3luY01hcChfZikge1xyXG4gICAgICAgIHJldHVybiBlcnJBc3luYyh0aGlzLmVycm9yKTtcclxuICAgIH1cclxuICAgIHVud3JhcE9yKHYpIHtcclxuICAgICAgICByZXR1cm4gdjtcclxuICAgIH1cclxuICAgIG1hdGNoKF9vaywgZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGVycih0aGlzLmVycm9yKTtcclxuICAgIH1cclxuICAgIHNhZmVVbndyYXAoKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmVycm9yO1xyXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgZXJyKGVycm9yKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEbyBub3QgdXNlIHRoaXMgZ2VuZXJhdG9yIG91dCBvZiBgc2FmZVRyeWAnKTtcclxuICAgICAgICB9KSgpO1xyXG4gICAgfVxyXG4gICAgX3Vuc2FmZVVud3JhcChjb25maWcpIHtcclxuICAgICAgICB0aHJvdyBjcmVhdGVOZXZlclRocm93RXJyb3IoJ0NhbGxlZCBgX3Vuc2FmZVVud3JhcGAgb24gYW4gRXJyJywgdGhpcywgY29uZmlnKTtcclxuICAgIH1cclxuICAgIF91bnNhZmVVbndyYXBFcnIoXykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGZyb21UaHJvd2FibGUgPSBSZXN1bHQuZnJvbVRocm93YWJsZTtcclxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEVyciwgT2ssIFJlc3VsdCwgUmVzdWx0QXN5bmMsIGVyciwgZXJyQXN5bmMsIGZyb21Qcm9taXNlLCBmcm9tU2FmZVByb21pc2UsIGZyb21UaHJvd2FibGUsIG9rLCBva0FzeW5jLCBzYWZlVHJ5IH07XG4iXSwibmFtZXMiOlsiZGVmYXVsdEVycm9yQ29uZmlnIiwid2l0aFN0YWNrVHJhY2UiLCJjcmVhdGVOZXZlclRocm93RXJyb3IiLCJtZXNzYWdlIiwicmVzdWx0IiwiY29uZmlnIiwiZGF0YSIsImlzT2siLCJ0eXBlIiwidmFsdWUiLCJlcnJvciIsIm1heWJlU3RhY2siLCJFcnJvciIsInN0YWNrIiwidW5kZWZpbmVkIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fdmFsdWVzIiwibyIsInMiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm0iLCJpIiwiY2FsbCIsImxlbmd0aCIsIlR5cGVFcnJvciIsIl9fYXdhaXQiLCJ2IiwiX19hc3luY0dlbmVyYXRvciIsImFzeW5jSXRlcmF0b3IiLCJnIiwicSIsInZlcmIiLCJuIiwiYSIsImIiLCJwdXNoIiwicmVzdW1lIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJmIiwic2hpZnQiLCJfX2FzeW5jRGVsZWdhdG9yIiwicCIsIl9fYXN5bmNWYWx1ZXMiLCJkIiwiUmVzdWx0QXN5bmMiLCJjb25zdHJ1Y3RvciIsInJlcyIsIl9wcm9taXNlIiwiZnJvbVNhZmVQcm9taXNlIiwicHJvbWlzZSIsIm5ld1Byb21pc2UiLCJPayIsImZyb21Qcm9taXNlIiwiZXJyb3JGbiIsImNhdGNoIiwiRXJyIiwiY29tYmluZSIsImFzeW5jUmVzdWx0TGlzdCIsImNvbWJpbmVSZXN1bHRBc3luY0xpc3QiLCJjb21iaW5lV2l0aEFsbEVycm9ycyIsImNvbWJpbmVSZXN1bHRBc3luY0xpc3RXaXRoQWxsRXJyb3JzIiwibWFwIiwiaXNFcnIiLCJtYXBFcnIiLCJhbmRUaGVuIiwibmV3VmFsdWUiLCJvckVsc2UiLCJtYXRjaCIsIm9rIiwiX2VyciIsInVud3JhcE9yIiwidCIsInNhZmVVbndyYXAiLCJhcmd1bWVudHMiLCJzYWZlVW53cmFwXzEiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsdXJlQ2FsbGJhY2siLCJva0FzeW5jIiwiZXJyQXN5bmMiLCJlcnIiLCJhcHBlbmRWYWx1ZVRvRW5kT2ZMaXN0IiwibGlzdCIsImNvbWJpbmVSZXN1bHRMaXN0IiwicmVzdWx0TGlzdCIsInJlZHVjZSIsImFjYyIsImFsbCIsImNvbWJpbmVSZXN1bHRMaXN0V2l0aEFsbEVycm9ycyIsIlJlc3VsdCIsImZyb21UaHJvd2FibGUiLCJmbiIsImFyZ3MiLCJzYWZlVHJ5IiwiYm9keSIsIl9mIiwiYXN5bmNBbmRUaGVuIiwiYXN5bmNNYXAiLCJfdiIsIl91bnNhZmVVbndyYXAiLCJfIiwiX3Vuc2FmZVVud3JhcEVyciIsIl9vayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/neverthrow/dist/index.es.js\n");

/***/ })

};
;